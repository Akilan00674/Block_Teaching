Single File Programming Question
Problem Statement



Arjun is working as an NLP engineer to improve the smart assistant chatbot in his company. His team wants the chatbot to understand user emotions better, especially when users repeat or emphasize words.



They noticed that palindromic patterns (like "wow", "pop", "madam") in messages can help detect such emotions or expressions.



To help with this, Arjun is asked to write a program that finds out how many palindromic substrings are centered at each character in the user's message.



Since the message could be long, Arjun decides to use Manacher’s Algorithm for fast and efficient processing.



Example:

Input

bananas

Output 

1 1 3 5 3 1 1 

Explanation

At the first character 'b', the only palindrome is "b" itself → length 1
At 'a', only "a" is a palindrome → length 1
At 'n', we get "ana" which is a palindrome centered at 'n' → length 3
At the middle 'a', we get "anana" which is a bigger palindrome → length 5
At the next 'n', again "ana" is a palindrome → length 3
At the second 'a', only "a" → length 1
Finally at 's', only "s" → length 1
Input format :
The first line of input contains a string s, representing a message typed by a user in the chatbot conversation.

Output format :
The output prints the length of the longest palindromic substring centered at each character in the input string, separated by spaces.



Refer to the sample output for formatting specifications.

Code constraints :
1 ≤ length of s ≤ 1000

Sample test cases :
Input 1 :
ab
Output 1 :
1 1 
Input 2 :
bananas
Output 2 :
1 1 3 5 3 1 1 













#include <bits/stdc++.h>
using namespace std;

string preprocess(const string &s) {
    string t = "^";
    for (char c : s) {
        t += "#";
        t += c;
    }
    t += "#$";
    return t;
}

vector<int> manacher(const string &s) {
    string t = preprocess(s);
    int n = t.size();
    vector<int> p(n, 0);
    int center = 0, right = 0;
    for (int i = 1; i < n - 1; i++) {
        int mir = 2 * center - i;
        if (i < right) p[i] = min(right - i, p[mir]);
        while (t[i + 1 + p[i]] == t[i - 1 - p[i]]) p[i]++;
        if (i + p[i] > right) {
            center = i;
            right = i + p[i];
        }
    }
    return p;
}

int main() {
    string s;
    cin >> s;
    int n = s.size();

    vector<int> p = manacher(s);
    string t = preprocess(s);

    vector<int> ans(n, 1);

    for (int i = 1; i < t.size() - 1; i++) {
        if (t[i] != '#') {
            int idx = (i - 1) / 2;
            ans[idx] = max(ans[idx], (p[i] / 2) * 2 + 1);
        }
    }

    for (int i = 0; i < n; i++) {
        cout << ans[i] << " ";
    }
    cout << "\n";
    return 0;
}
