Single File Programming Question
Problem Statement



﻿Arya is a junior software developer working in the cyber-defense unit of a national security agency. Her team is analyzing message strings that might have been tampered with during transmission.



After investigation, they noticed that some suspicious messages can be split into two non-empty palindromic substrings. These patterns may indicate possible data manipulation.



To detect such patterns efficiently, Arya decides to use Manacher’s Algorithm, which is known for finding palindromic substrings in linear time.

Input format :
The first line of input contains a string s representing the message to be analyzed.

Output format :
If a valid split exists :

The first line of output prints "true"
The second line of output prints "<first_palindrome> <second_palindrome>"
If no valid split exists:

The first line of output prints "false"


﻿Refer to the sample output for formatting specifications.

Code constraints :
1 ≤ length of s ≤ 1000

Sample test cases :
Input 1 :
noonmadam
Output 1 :
true
noon madam
Input 2 :
aaa
Output 2 :
true
a aa
Input 3 :
aabbbaa
Output 3 :
false
Input 4 :
noon
Output 4 :
false








#include <bits/stdc++.h>
using namespace std;

string preprocess(const string &s) {
    string t = "^";
    for (char c : s) {
        t += "#";
        t += c;
    }
    t += "#$";
    return t;
}

vector<int> manacher(const string &s) {
    string t = preprocess(s);
    int n = t.size();
    vector<int> p(n, 0);
    int center = 0, right = 0;
    for (int i = 1; i < n - 1; i++) {
        int mir = 2 * center - i;
        if (i < right) p[i] = min(right - i, p[mir]);
        while (t[i + 1 + p[i]] == t[i - 1 - p[i]]) p[i]++;
        if (i + p[i] > right) {
            center = i;
            right = i + p[i];
        }
    }
    return p;
}

int main() {
    string s;
    cin >> s;
    int n = s.size();

    vector<int> p = manacher(s);
    string t = preprocess(s);

    vector<bool> leftPal(n, false), rightPal(n, false);

    // derive original indices correctly
    for (int i = 1; i < t.size() - 1; i++) {
        int len = p[i];
        int start = (i - len) / 2;
        int end = start + len - 1;
        if (start == 0 && end >= 0 && end < n) {
            leftPal[end] = true;
        }
        if (end == n - 1 && start >= 0 && start < n) {
            rightPal[start] = true;
        }
    }

    // check split
    for (int i = 0; i < n - 1; i++) {
        if (leftPal[i] && rightPal[i + 1]) {
            cout << "true\n";
            cout << s.substr(0, i + 1) << " " << s.substr(i + 1) << "\n";
            return 0;
        }
    }

    cout << "false\n";
    return 0;
}
