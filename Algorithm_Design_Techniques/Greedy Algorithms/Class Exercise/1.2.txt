Single File Programming Question
Problem Statement:



Ram is planning activities for a person during the day. He has a list of activities, and each activity has a start time and an end time. The person can only do one activity at a time, and they need to maximize the number of activities they can participate in. His goal is to select the maximum number of non-overlapping activities. Help Ram to complete the task.

Input format :
The first line of input is an integer n, representing the number of activities.

The second line of input consists of n space-separated integers representing the start times of the activities.

The third line of input consists of n space-separated integers representing the finish times of the activities.

Output format :
The output displays the indices of the selected activities separated by a space, representing the maximum number of activities that can be performed.



Refer to the sample output for the formatting specifications.

Code constraints :
1 ≤ Start time, Finish time ≤ 100

Start time < Finish time

Sample test cases :
Input 1 :
6
1 3 0 5 8 5
2 4 6 7 9 9
Output 1 :
0 1 3 4



#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

struct Activity {
    int index;
    int start;
    int finish;
};

bool compareFinish(const Activity &a, const Activity &b) {
    return a.finish < b.finish;
}

int main() {
    int n;
    cin >> n;
    vector<int> start(n), finish(n);
    for (int i = 0; i < n; i++) cin >> start[i];
    for (int i = 0; i < n; i++) cin >> finish[i];

    vector<Activity> activities(n);
    for (int i = 0; i < n; i++) {
        activities[i] = {i, start[i], finish[i]};
    }

    sort(activities.begin(), activities.end(), compareFinish);

    vector<int> selected;
    int lastFinish = -1;
    for (auto &act : activities) {
        if (act.start >= lastFinish) {
            selected.push_back(act.index);
            lastFinish = act.finish;
        }
    }

    sort(selected.begin(), selected.end()); // sort indices in original input order

    for (int i = 0; i < selected.size(); i++) {
        cout << selected[i];
        if (i != selected.size() - 1) cout << " ";
    }
    cout << endl;

    return 0;
}// ONE TEST CASE WILL FAILS
