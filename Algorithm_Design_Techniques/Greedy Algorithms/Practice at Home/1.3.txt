Single File Programming Question
Problem Statement



Raj is a keen entrepreneur who is venturing into the business of selling items. He has a limited capacity backpack and wants to maximize his profit by selecting items to carry in his backpack. Each item has a weight and a corresponding profit. However, Raj can carry fractions of items to maximize his profit within the capacity of his backpack.



Write a program to help Raj determine the maximum profit he can achieve by using the fractional knapsack algorithm.

Input format :
The first line of input is an integer num, representing the number of items available.

The next num lines of input consists of two space-separated double-point numbers weight[i] and profit[i], representing the weight and profit of the i-th item respectively.

The last line of input consists of a single double-point number capacity, representing the maximum weight capacity of Raj's backpack.

Output format :
The output displays the following format:



The first line should display double point numbers, representing the fractions of each item selected, rounded to two decimal places.

The second line should display double point numbers, representing the maximum profit Raj can achieve, rounded to two decimal places.



Refer to the sample outputs for the formatting specifications.

Code constraints :
1 ≤ num ≤ 15

1.0 ≤ profit[i], weight[i] ≤ 1000.0

1.0 ≤ capacity ≤ 100.0

Sample test cases :
Input 1 :
3
10.0 60.0
20.0 100.0
30.0 120.0
50.0
Output 1 :
Fractions: 1.00 1.00 0.67 
Maximum profit is: 240.00
Input 2 :
4
10.0 100.0
40.0 280.0
20.0 120.0
24.0 120.0
60.0
Output 2 :
Fractions: 1.00 1.00 0.50 0.00 
Maximum profit is: 440.00








#include <bits/stdc++.h>
using namespace std;

struct Item {
    double weight, profit, ratio;
    int index;
};

int main() {
    int num;
    cin >> num;
    vector<Item> items(num);
    for (int i = 0; i < num; i++) {
        cin >> items[i].weight >> items[i].profit; // weight first, then profit
        items[i].ratio = items[i].profit / items[i].weight;
        items[i].index = i;
    }
    double capacity;
    cin >> capacity;

    sort(items.begin(), items.end(), [](Item &a, Item &b) {
        return a.ratio > b.ratio;
    });

    vector<double> fractions(num, 0.0);
    double maxProfit = 0.0;

    for (int i = 0; i < num && capacity > 0; i++) {
        if (items[i].weight <= capacity) {
            fractions[items[i].index] = 1.0;
            maxProfit += items[i].profit;
            capacity -= items[i].weight;
        } else {
            fractions[items[i].index] = capacity / items[i].weight;
            maxProfit += items[i].profit * fractions[items[i].index];
            capacity = 0;
        }
    }

    cout << "Fractions: ";
    for (int i = 0; i < num; i++) {
        cout << fixed << setprecision(2) << fractions[i] << " ";
    }
    cout << "\nMaximum profit is: " << fixed << setprecision(2) << maxProfit;
    return 0;//not all test case passed
}
