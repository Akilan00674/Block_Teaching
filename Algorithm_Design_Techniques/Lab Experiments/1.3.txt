Single File Programming Question
Problem Statement



Dr. Nila is working on a smart energy meter that continuously logs voltage readings. She has observed that sometimes, due to power fluctuations or interference, the sensor readings form symmetric patterns - sequences that read the same forward and backward.



To identify such phenomena quickly and efficiently, Dr. Nila wants to find the longest palindromic subsequence in a list of readings.



Since performance is critical, she decides to use Manacher’s Algorithm to find the longest palindromic substring in a string of digits (where each digit represents a reading). Help her implement this solution.

Input format :
The first line of input contains a string s made up of digits (0-9), representing voltage readings.

Output format :
The output displays a string representing the longest palindromic substring of the given numeric string.



﻿Refer to the sample output for formatting specifications.

Code constraints :
0 ≤ Length of the strings ≤ 50

The input string contains only digits.

If there are multiple longest palindromic substrings of the same length, return the one that appears first.

Sample test cases :
Input 1 :
1000001
Output 1 :
1000001
Input 2 :
98765433215678
Output 2 :
33
Input 3 :
111222333
Output 3 :
111








#include <bits/stdc++.h>
using namespace std;

string preprocess(const string &s) {
    if (s.empty()) return "^$";
    string t = "^";
    for (char c : s) {
        t += "#";
        t += c;
    }
    t += "#$";
    return t;
}

string longestPalindrome(const string &s) {
    string t = preprocess(s);
    int n = t.size();
    vector<int> p(n, 0);
    int center = 0, right = 0;

    int maxLen = 0, centerIndex = 0;

    for (int i = 1; i < n - 1; i++) {
        int mir = 2 * center - i;

        if (i < right)
            p[i] = min(right - i, p[mir]);

        while (t[i + 1 + p[i]] == t[i - 1 - p[i]])
            p[i]++;

        if (i + p[i] > right) {
            center = i;
            right = i + p[i];
        }

        if (p[i] > maxLen) {
            maxLen = p[i];
            centerIndex = i;
        }
    }

    int start = (centerIndex - maxLen) / 2;
    return s.substr(start, maxLen);
}

int main() {
    string s;
    cin >> s;

    if (s.empty()) {
        cout << "" << endl;
        return 0;
    }

    cout << longestPalindrome(s) << endl;
    return 0;
}
