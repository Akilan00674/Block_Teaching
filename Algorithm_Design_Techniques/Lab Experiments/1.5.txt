Single File Programming Question
Problem Statement



Lydia is a jewelry designer who is about to showcase her collection at a prestigious exhibition. She has a limited display space and needs to choose a subset of her jewelry items to display that will maximize her total value while staying within the space constraints. Each piece of jewelry has a certain weight and value associated with it. Your task is to help Lydia choose the best combination of jewelry pieces to maximize her total display value without exceeding the available space in her showcase.



To solve this problem, you will implement the Branch and Bound algorithm to determine the maximum value that Lydia can display.

Input format :
The first line of input consists of two integers, G and H, where:

G represents the number of jewelry items.
H represents the total available weight capacity of the display showcase.
The second line consists of G integers representing the weight of each jewelry item.

The third line consists of G integers representing the value of each jewelry item.

Output format :
The output should print the maximum total value Lydia can display, rounded to two decimal places.



Refer to the sample output for formatting specifications.﻿

Code constraints :
The given test cases fall under the following specifications:

1 ≤ G ≤ 100

1 ≤ H ≤ 1000

1 ≤ weight[i] ≤ 100

1 ≤ value[i] ≤ 1000

Sample test cases :
Input 1 :
4 10
2 3 5 4
40 50 100 60
Output 1 :
190.00
Input 2 :
5 15
2 3 4 5 6
50 60 70 80 90
Output 2 :
270.00










#include <bits/stdc++.h>
using namespace std;

struct Item {
    int weight, value;
    double ratio;
};

struct Node {
    int level;
    int profit;
    int weight;
    double bound;
};

bool cmp(Item a, Item b) {
    return a.ratio > b.ratio;
}

double bound(Node u, int n, int W, vector<Item>& arr) {
    if (u.weight >= W) return 0;
    double profit_bound = u.profit;
    int j = u.level + 1;
    int totweight = u.weight;

    while ((j < n) && (totweight + arr[j].weight <= W)) {
        totweight += arr[j].weight;
        profit_bound += arr[j].value;
        j++;
    }
    if (j < n)
        profit_bound += (W - totweight) * arr[j].ratio;

    return profit_bound;
}

int knapsack(int W, vector<Item>& arr, int n) {
    sort(arr.begin(), arr.end(), cmp);

    queue<Node> Q;
    Node u, v;

    v.level = -1;
    v.profit = v.weight = 0;
    Q.push(v);

    int maxProfit = 0;
    while (!Q.empty()) {
        v = Q.front();
        Q.pop();

        if (v.level == n - 1) continue;

        u.level = v.level + 1;
        u.weight = v.weight + arr[u.level].weight;
        u.profit = v.profit + arr[u.level].value;

        if (u.weight <= W && u.profit > maxProfit)
            maxProfit = u.profit;

        u.bound = bound(u, n, W, arr);
        if (u.bound > maxProfit) Q.push(u);

        u.weight = v.weight;
        u.profit = v.profit;
        u.bound = bound(u, n, W, arr);
        if (u.bound > maxProfit) Q.push(u);
    }
    return maxProfit;
}

int main() {
    int G, H;
    cin >> G >> H;

    vector<int> weights(G), values(G);
    for (int i = 0; i < G; i++) cin >> weights[i];
    for (int i = 0; i < G; i++) cin >> values[i];

    vector<Item> arr(G);
    for (int i = 0; i < G; i++) {
        arr[i].weight = weights[i];
        arr[i].value = values[i];
        arr[i].ratio = (double)values[i] / weights[i];
    }

    int result = knapsack(H, arr, G);
    cout << fixed << setprecision(2) << (double)result << endl;

    return 0;
}
